<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Bitmap 相关错误" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/23/Bitmap 相关错误/" class="article-date">
  <time datetime="2017-11-23T03:17:19.803Z" itemprop="datePublished">2017-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Bitmap-相关错误"><a href="#Bitmap-相关错误" class="headerlink" title="Bitmap 相关错误"></a>Bitmap 相关错误</h1><h1 id="android-Immutable-bitmap-passed-to-Canvas-constructor异常"><a href="#android-Immutable-bitmap-passed-to-Canvas-constructor异常" class="headerlink" title="android Immutable bitmap passed to Canvas constructor异常"></a>android Immutable bitmap passed to Canvas constructor异常</h1><p>出现Immutable bitmap passed to Canvas constructor错误的原因是如果不用copy的方法，直接引用会对资源文件进行修改，而Android是不允许在代码里修改res文件里的图片</p>
<p>解决办法如下：</p>
<p>使用</p>
<figure class="highlight plain"><figcaption><span>R.drawable.xiao).copy(Bitmap.Config.ARGB_8888, true);  ````</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">替换</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">````BitmapFactory.decodeResource(getResources(), R.drawable.xiao);</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/23/Bitmap 相关错误/" data-id="cjabwqtn5000dhhyuu7id4cz4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android 移动端与tomcat 连接测试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/23/Android 移动端与tomcat 连接测试/" class="article-date">
  <time datetime="2017-11-23T03:17:19.803Z" itemprop="datePublished">2017-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android-移动端与tomcat-连接测试"><a href="#Android-移动端与tomcat-连接测试" class="headerlink" title="Android 移动端与tomcat 连接测试"></a>Android 移动端与tomcat 连接测试</h1><h2 id="使用模拟器，而不是真机，请求本地Tomcat-HTTP-访问报错："><a href="#使用模拟器，而不是真机，请求本地Tomcat-HTTP-访问报错：" class="headerlink" title="使用模拟器，而不是真机，请求本地Tomcat ,HTTP 访问报错："></a>使用模拟器，而不是真机，请求本地Tomcat ,HTTP 访问报错：</h2><p>exception = failed to connect to /127.0.0.1 (port 8089): connect failed: ECONNREFUSED (Connection refused)<br>10-19 02:28:04.166: W/BroadcastQueue(336): Timeout of broadcast BroadcastRecord{dc8a0f6 u0 android.intent.action.BOOT_COMPLETED} -</p>
<p>——&gt;解决：不能用localhost/127.0.0.1 访问，把localhost改为10.0.2.2已经解决。</p>
<h2 id="手机连接PC-Tomcat"><a href="#手机连接PC-Tomcat" class="headerlink" title="手机连接PC Tomcat:"></a>手机连接PC Tomcat:</h2><p>1.设置PC端的防火墙，参考：<a href="http://blog.csdn.net/chendc201/article/details/22905489" target="_blank" rel="noopener">http://blog.csdn.net/chendc201/article/details/22905489</a><br>2.手机和PC同在一个局域网下的AP</p>
<ol>
<li>直接访问<a href="http://192.168.14.24:8089/" target="_blank" rel="noopener">http://192.168.14.24:8089/</a> 测试</li>
</ol>
<p>如果有个无线路由器，电脑和Android手机都连接上了这个路由器的话，就可以通过无线局域网来访问电脑端的tomcat，从而让电脑成为手机服务的服务端。</p>
<p>开启电脑的CMD，输入ipconfig。可查看到本机的局域网地址。</p>
<p>可知我本机的地址为：<a href="http://10.0.0.2。" target="_blank" rel="noopener">http://10.0.0.2。</a></p>
<p>在手机上，查看wifi的属性，可知局域网的地址为：10.0.0.3。两台设备都在同一个局域网里面的。</p>
<p>开启tomcat，打开一个浏览器，在地址栏里面输入地址+端口号。默认的端口号为8080.所以就是输入：<a href="http://10.0.0.2:8080/" target="_blank" rel="noopener">http://10.0.0.2:8080/</a></p>
<p>电脑上能访问，那么手机上应该也能访问了。打开手机的浏览器，在里面输入一样的地址，发现手机打开网页很慢，最后提示无法访问。由此可知应该是电脑上的防火墙限制了，关闭电脑上的防火墙：</p>
<p>再刷新一下手机，发现终于可以访问了。以后开发手机客户端就可以连接服务器，访问电脑上的资源和操作数据库了……</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/23/Android 移动端与tomcat 连接测试/" data-id="cjabwqtm60008hhyuaansmbd8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-android 杂项" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/23/android 杂项/" class="article-date">
  <time datetime="2017-11-23T03:17:19.791Z" itemprop="datePublished">2017-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="不同的点击事件"><a href="#不同的点击事件" class="headerlink" title="不同的点击事件"></a>不同的点击事件</h2><p>1 relativelayout 代码有点击监听</p>
<p>textview drawableright tv.selector  </p>
<p>单击rl drawable可变化</p>
<p>imagebutton selector 不变</p>
<p>(imageview selector 变化了。。)</p>
<p>单击 ib ib.selector 变化  rl不能收到监听事件</p>
<p>2 imageview selector 要可变的话</p>
<p>android:clickalbe = “true”<br>或代码里做了监听事件</p>
<p>（可能tv 等同理）</p>
<h2 id="viewpager-和-fragmentPageradapter-使用"><a href="#viewpager-和-fragmentPageradapter-使用" class="headerlink" title="viewpager 和 fragmentPageradapter 使用"></a>viewpager 和 fragmentPageradapter 使用</h2><p>new 3 个fragment 都生成了，但第三个 fragment 控件id 都为空， 没执行 oncreateview 方法</p>
<p>—使用 viewpager.setOffscreenPageLimit(3)  可行 *（不知道为什么）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/23/android 杂项/" data-id="cjabwqtny000xhhyu2or0xwgf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-android 打包相关问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/23/android 打包相关问题/" class="article-date">
  <time datetime="2017-11-23T03:17:19.787Z" itemprop="datePublished">2017-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="android-打包相关问题"><a href="#android-打包相关问题" class="headerlink" title="android  打包相关问题"></a>android  打包相关问题</h1><h2 id="What-went-wrong"><a href="#What-went-wrong" class="headerlink" title="* What went wrong:"></a>* What went wrong:</h2><p>Execution failed for task ‘:app:transformClassesWithDexForRelease’.</p>
<blockquote>
<p>com.android.build.api.transform.TransformException: com.android.ide.common.process.ProcessException: java.util.concurrent.ExecutionException:<br>com.android.dex.DexException: Multiple dex files define Landroid/support/v4/accessibilityservice/AccessibilityServiceInfoCompat$AccessibilitySer<br>viceInfoVersionImpl;</p>
</blockquote>
<ul>
<li>Try:<br>Run with –stacktrace option to get the stack trace. Run with –info or –debug option to get more log output.</li>
</ul>
<p>BUILD FAILED</p>
<p>查看是否引用多余的 v4 jar </p>
<blockquote>
<p>最后发现其实是引用工程libs目录下有一个android-support-v4.jar包，通过compile fileTree(include: ‘*.jar’, dir: ‘libs’)来引入v4包的，把这个jar包删除，改为gradle引入 compile ‘com.android.support:support-v4:24.1.1’问题解决，可能是gradle引入的gradle才能自动解决重复的包，而通过jar包引入的gradle处理不了）</p>
</blockquote>
<p>设置GRADLE_HOME环境变量和path，具体地址可查看android studio – file –setting 搜gradle</p>
<p>命令行执行gradle -v正常的话<br>到项目路径执行gradle -q app:dependencies 或到app module下执行gradle -q dependencies查看依赖树</p>
<pre><code>D:\Travel&gt;gradle -q app:dependencies

------------------------------------------------------------
Project :app
------------------------------------------------------------

_debugAndroidTestAnnotationProcessor - ## Internal use, do not manually configure ##
No dependencies

_debugAndroidTestApk - ## Internal use, do not manually configure ##
No dependencies

_debugAndroidTestCompile - ## Internal use, do not manually configure ##
No dependencies

_debugAnnotationProcessor - ## Internal use, do not manually configure ##
No dependencies

_debugApk - ## Internal use, do not manually configure ##
+--- com.meituan.android.walle:library:1.1.5
|    +--- com.android.support:support-annotations:24.1.1 -&gt; 25.2.0
|    \--- com.meituan.android.walle:payload_reader:1.1.5
+--- com.android.support:design:23.2.1
|    +--- com.android.support:support-v4:23.2.1
|    |    \--- com.android.support:support-annotations:23.2.1 -&gt; 25.2.0
|    +--- com.android.support:appcompat-v7:23.2.1
|    |    +--- com.android.support:animated-vector-drawable:23.2.1
|    |    |    \--- com.android.support:support-vector-drawable:23.2.1
|    |    |         \--- com.android.support:support-v4:23.2.1 (*)
|    |    +--- com.android.support:support-vector-drawable:23.2.1 (*)
|    |    \--- com.android.support:support-v4:23.2.1 (*)
|    \--- com.android.support:recyclerview-v7:23.2.1 -&gt; 25.2.0
|         +--- com.android.support:support-annotations:25.2.0
|         +--- com.android.support:support-compat:25.2.0
|         |    \--- com.android.support:support-annotations:25.2.0
|         \--- com.android.support:support-core-ui:25.2.0
|              +--- com.android.support:support-annotations:25.2.0
|              \--- com.android.support:support-compat:25.2.0 (*)
+--- com.android.support:appcompat-v7:23.2.1 (*)
+--- com.squareup.retrofit2:retrofit:2.1.0
|    \--- com.squareup.okhttp3:okhttp:3.3.0 -&gt; 3.4.1
|         \--- com.squareup.okio:okio:1.9.0
+--- com.squareup.retrofit2:converter-gson:2.1.0
|    +--- com.squareup.retrofit2:retrofit:2.1.0 (*)
|    \--- com.google.code.gson:gson:2.7
+--- com.squareup.okhttp3:logging-interceptor:3.1.2
|    \--- com.squareup.okhttp3:okhttp:3.1.2 -&gt; 3.4.1 (*)
+--- com.apkfuns.logutils:library:1.0.6
+--- com.squareup.okio:okio:1.9.0
+--- com.squareup.okhttp3:okhttp:3.4.1 (*)
+--- com.android.support:recyclerview-v7:23.2.1 -&gt; 25.2.0 (*)
+--- com.android.support:cardview-v7:23.2.1
+--- com.jakewharton:butterknife:8.4.0
|    +--- com.jakewharton:butterknife-annotations:8.4.0
|    |    \--- com.android.support:support-annotations:24.1.0 -&gt; 25.2.0
|    \--- com.android.support:support-annotations:24.1.0 -&gt; 25.2.0
+--- com.squareup.picasso:picasso:2.5.2
+--- com.yanzhenjie:recyclerview-swipe:1.0.4
|    \--- com.android.support:recyclerview-v7:25.2.0 (*)
+--- com.google.zxing:core:3.2.1
\--- com.journeyapps:zxing-android-embedded:3.3.0
     +--- com.google.zxing:core:3.2.1
     \--- com.android.support:support-v4:23.1.0 -&gt; 23.2.1 (*)

_debugCompile - ## Internal use, do not manually configure ##
+--- com.meituan.android.walle:library:1.1.5
|    +--- com.android.support:support-annotations:24.1.1 -&gt; 25.2.0
|    \--- com.meituan.android.walle:payload_reader:1.1.5
+--- com.android.support:design:23.2.1
|    +--- com.android.support:support-v4:23.2.1
|    |    \--- com.android.support:support-annotations:23.2.1 -&gt; 25.2.0
|    +--- com.android.support:appcompat-v7:23.2.1
|    |    +--- com.android.support:animated-vector-drawable:23.2.1
|    |    |    \--- com.android.support:support-vector-drawable:23.2.1
|    |    |         \--- com.android.support:support-v4:23.2.1 (*)
|    |    +--- com.android.support:support-vector-drawable:23.2.1 (*)
|    |    \--- com.android.support:support-v4:23.2.1 (*)
|    \--- com.android.support:recyclerview-v7:23.2.1 -&gt; 25.2.0
|         +--- com.android.support:support-annotations:25.2.0
|         +--- com.android.support:support-compat:25.2.0
|         |    \--- com.android.support:support-annotations:25.2.0
|         \--- com.android.support:support-core-ui:25.2.0
|              +--- com.android.support:support-annotations:25.2.0
|              \--- com.android.support:support-compat:25.2.0 (*)
+--- com.android.support:appcompat-v7:23.2.1 (*)
+--- com.squareup.retrofit2:retrofit:2.1.0
|    \--- com.squareup.okhttp3:okhttp:3.3.0 -&gt; 3.4.1
|         \--- com.squareup.okio:okio:1.9.0
+--- com.squareup.retrofit2:converter-gson:2.1.0
|    +--- com.squareup.retrofit2:retrofit:2.1.0 (*)
|    \--- com.google.code.gson:gson:2.7
+--- com.squareup.okhttp3:logging-interceptor:3.1.2
|    \--- com.squareup.okhttp3:okhttp:3.1.2 -&gt; 3.4.1 (*)
+--- com.apkfuns.logutils:library:1.0.6
+--- com.squareup.okio:okio:1.9.0
+--- com.squareup.okhttp3:okhttp:3.4.1 (*)
+--- com.android.support:recyclerview-v7:23.2.1 -&gt; 25.2.0 (*)
+--- com.android.support:cardview-v7:23.2.1
+--- com.jakewharton:butterknife:8.4.0
|    +--- com.jakewharton:butterknife-annotations:8.4.0
|    |    \--- com.android.support:support-annotations:24.1.0 -&gt; 25.2.0
|    \--- com.android.support:support-annotations:24.1.0 -&gt; 25.2.0
+--- com.squareup.picasso:picasso:2.5.2
+--- com.yanzhenjie:recyclerview-swipe:1.0.4
|    \--- com.android.support:recyclerview-v7:25.2.0 (*)
+--- com.google.zxing:core:3.2.1
\--- com.journeyapps:zxing-android-embedded:3.3.0
     +--- com.google.zxing:core:3.2.1
     \--- com.android.support:support-v4:23.1.0 -&gt; 23.2.1 (*)

_debugUnitTestAnnotationProcessor - ## Internal use, do not manually configure ##
No dependencies

_debugUnitTestApk - ## Internal use, do not manually configure ##
\--- junit:junit:4.12
     \--- org.hamcrest:hamcrest-core:1.3

_debugUnitTestCompile - ## Internal use, do not manually configure ##
\--- junit:junit:4.12
     \--- org.hamcrest:hamcrest-core:1.3

_releaseAnnotationProcessor - ## Internal use, do not manually configure ##
No dependencies

_releaseApk - ## Internal use, do not manually configure ##
+--- com.meituan.android.walle:library:1.1.5
|    +--- com.android.support:support-annotations:24.1.1 -&gt; 25.2.0
|    \--- com.meituan.android.walle:payload_reader:1.1.5
+--- com.android.support:design:23.2.1
|    +--- com.android.support:support-v4:23.2.1
|    |    \--- com.android.support:support-annotations:23.2.1 -&gt; 25.2.0
|    +--- com.android.support:appcompat-v7:23.2.1
|    |    +--- com.android.support:animated-vector-drawable:23.2.1
|    |    |    \--- com.android.support:support-vector-drawable:23.2.1
|    |    |         \--- com.android.support:support-v4:23.2.1 (*)
|    |    +--- com.android.support:support-vector-drawable:23.2.1 (*)
|    |    \--- com.android.support:support-v4:23.2.1 (*)
|    \--- com.android.support:recyclerview-v7:23.2.1 -&gt; 25.2.0
|         +--- com.android.support:support-annotations:25.2.0
|         +--- com.android.support:support-compat:25.2.0
|         |    \--- com.android.support:support-annotations:25.2.0
|         \--- com.android.support:support-core-ui:25.2.0
|              +--- com.android.support:support-annotations:25.2.0
|              \--- com.android.support:support-compat:25.2.0 (*)
+--- com.android.support:appcompat-v7:23.2.1 (*)
+--- com.squareup.retrofit2:retrofit:2.1.0
|    \--- com.squareup.okhttp3:okhttp:3.3.0 -&gt; 3.4.1
|         \--- com.squareup.okio:okio:1.9.0
+--- com.squareup.retrofit2:converter-gson:2.1.0
|    +--- com.squareup.retrofit2:retrofit:2.1.0 (*)
|    \--- com.google.code.gson:gson:2.7
+--- com.squareup.okhttp3:logging-interceptor:3.1.2
|    \--- com.squareup.okhttp3:okhttp:3.1.2 -&gt; 3.4.1 (*)
+--- com.apkfuns.logutils:library:1.0.6
+--- com.squareup.okio:okio:1.9.0
+--- com.squareup.okhttp3:okhttp:3.4.1 (*)
+--- com.android.support:recyclerview-v7:23.2.1 -&gt; 25.2.0 (*)
+--- com.android.support:cardview-v7:23.2.1
+--- com.jakewharton:butterknife:8.4.0
|    +--- com.jakewharton:butterknife-annotations:8.4.0
|    |    \--- com.android.support:support-annotations:24.1.0 -&gt; 25.2.0
|    \--- com.android.support:support-annotations:24.1.0 -&gt; 25.2.0
+--- com.squareup.picasso:picasso:2.5.2
+--- com.yanzhenjie:recyclerview-swipe:1.0.4
|    \--- com.android.support:recyclerview-v7:25.2.0 (*)
+--- com.google.zxing:core:3.2.1
\--- com.journeyapps:zxing-android-embedded:3.3.0
     +--- com.google.zxing:core:3.2.1
     \--- com.android.support:support-v4:23.1.0 -&gt; 23.2.1 (*)

_releaseCompile - ## Internal use, do not manually configure ##
+--- com.meituan.android.walle:library:1.1.5
|    +--- com.android.support:support-annotations:24.1.1 -&gt; 25.2.0
|    \--- com.meituan.android.walle:payload_reader:1.1.5
+--- com.android.support:design:23.2.1
|    +--- com.android.support:support-v4:23.2.1
|    |    \--- com.android.support:support-annotations:23.2.1 -&gt; 25.2.0
|    +--- com.android.support:appcompat-v7:23.2.1
|    |    +--- com.android.support:animated-vector-drawable:23.2.1
|    |    |    \--- com.android.support:support-vector-drawable:23.2.1
|    |    |         \--- com.android.support:support-v4:23.2.1 (*)
|    |    +--- com.android.support:support-vector-drawable:23.2.1 (*)
|    |    \--- com.android.support:support-v4:23.2.1 (*)
|    \--- com.android.support:recyclerview-v7:23.2.1 -&gt; 25.2.0
|         +--- com.android.support:support-annotations:25.2.0
|         +--- com.android.support:support-compat:25.2.0
|         |    \--- com.android.support:support-annotations:25.2.0
|         \--- com.android.support:support-core-ui:25.2.0
|              +--- com.android.support:support-annotations:25.2.0
|              \--- com.android.support:support-compat:25.2.0 (*)
+--- com.android.support:appcompat-v7:23.2.1 (*)
+--- com.squareup.retrofit2:retrofit:2.1.0
|    \--- com.squareup.okhttp3:okhttp:3.3.0 -&gt; 3.4.1
|         \--- com.squareup.okio:okio:1.9.0
+--- com.squareup.retrofit2:converter-gson:2.1.0
|    +--- com.squareup.retrofit2:retrofit:2.1.0 (*)
|    \--- com.google.code.gson:gson:2.7
+--- com.squareup.okhttp3:logging-interceptor:3.1.2
|    \--- com.squareup.okhttp3:okhttp:3.1.2 -&gt; 3.4.1 (*)
+--- com.apkfuns.logutils:library:1.0.6
+--- com.squareup.okio:okio:1.9.0
+--- com.squareup.okhttp3:okhttp:3.4.1 (*)
+--- com.android.support:recyclerview-v7:23.2.1 -&gt; 25.2.0 (*)
+--- com.android.support:cardview-v7:23.2.1
+--- com.jakewharton:butterknife:8.4.0
|    +--- com.jakewharton:butterknife-annotations:8.4.0
|    |    \--- com.android.support:support-annotations:24.1.0 -&gt; 25.2.0
|    \--- com.android.support:support-annotations:24.1.0 -&gt; 25.2.0
+--- com.squareup.picasso:picasso:2.5.2
+--- com.yanzhenjie:recyclerview-swipe:1.0.4
|    \--- com.android.support:recyclerview-v7:25.2.0 (*)
+--- com.google.zxing:core:3.2.1
\--- com.journeyapps:zxing-android-embedded:3.3.0
     +--- com.google.zxing:core:3.2.1
     \--- com.android.support:support-v4:23.1.0 -&gt; 23.2.1 (*)

_releaseUnitTestAnnotationProcessor - ## Internal use, do not manually configure ##
No dependencies

_releaseUnitTestApk - ## Internal use, do not manually configure ##
\--- junit:junit:4.12
     \--- org.hamcrest:hamcrest-core:1.3

_releaseUnitTestCompile - ## Internal use, do not manually configure ##
\--- junit:junit:4.12
     \--- org.hamcrest:hamcrest-core:1.3

androidJacocoAgent - The Jacoco agent to use to get coverage data.
\--- org.jacoco:org.jacoco.agent:0.7.5.201505241946

androidJacocoAnt - The Jacoco ant tasks to use to get execute Gradle tasks.
\--- org.jacoco:org.jacoco.ant:0.7.5.201505241946
     +--- org.jacoco:org.jacoco.core:0.7.5.201505241946
     |    \--- org.ow2.asm:asm-debug-all:5.0.1
     +--- org.jacoco:org.jacoco.report:0.7.5.201505241946
     |    +--- org.jacoco:org.jacoco.core:0.7.5.201505241946 (*)
     |    \--- org.ow2.asm:asm-debug-all:5.0.1
     \--- org.jacoco:org.jacoco.agent:0.7.5.201505241946

androidTestAnnotationProcessor - Classpath for the annotation processor for &apos;androidTest&apos;.
No dependencies

androidTestApk - Classpath packaged with the compiled &apos;androidTest&apos; classes.
No dependencies

androidTestApt
</code></pre><p>不同包引入重复冲突了，各种exclude，如下，</p>
<blockquote>
<p>compile (‘com.android.support:recyclerview-v7:+’){<br>exclude module: ‘support-v4’    //exclude group: “com.android.support”, module: “support-v4”<br>}</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/23/android 打包相关问题/" data-id="cjabwqtnv000whhyus92xpsue" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android开发中，有哪些让你觉得相见恨晚的方法、类或接口" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/23/Android开发中，有哪些让你觉得相见恨晚的方法、类或接口/" class="article-date">
  <time datetime="2017-11-23T03:17:19.783Z" itemprop="datePublished">2017-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android开发中，有哪些让你觉得相见恨晚的方法、类或接口"><a href="#Android开发中，有哪些让你觉得相见恨晚的方法、类或接口" class="headerlink" title="Android开发中，有哪些让你觉得相见恨晚的方法、类或接口"></a>Android开发中，有哪些让你觉得相见恨晚的方法、类或接口</h1><p><a href="https://www.zhihu.com/question/33636939" target="_blank" rel="noopener">Android开发中，有哪些让你觉得相见恨晚的方法、类或接口</a></p>
<p>Part 1：Activity.startActivities() 常用于在应用程序中间启动其他的Activity。TextUtils.isEmpty() 简单的工具类,用于检测是否为空。Html.fromHtml() 用于生成一个Html,参数可以是一个字符串.个人认为它不是很快,所以我不怎么经常去用.（我说不经常用它是为了重点突出这句话：请多手动构建 Spannable 来替换 Html.fromHtml），但是它对渲染从 web 上获取的文字还是很不错的。TextView.setError() 在验证用户输入的时候很棒。Build.VERSION_CODES 这个标明了当前的版本号,在处理兼容性问题的时候经常会用到.点进去可以看到各个版本的不同特性。Log.getStackTraceString() 方便的日志类工具,方法Log.v()、Log.d()、Log.i()、Log.w()和Log.e()都是将信息打印到LogCat中，有时候需要将出错的信息插入到数据库或一个自定义的日志文件中，那么这种情况就需要将出错的信息以字符串的形式返回来，也就是使用static String getStackTraceString(Throwable tr)方法的时候。LayoutInflater.from() 顾名思义,用于Inflate一个layout,参数是layout的id.这个经常写Adapter的人会用的比较多。ViewConfiguration.getScaledTouchSlop() 使用 ViewConfiguration 中提供的值以保证所有触摸的交互都是统一的。这个方法获取的值表示:用户的手滑动这个距离后,才判定为正在进行滑动.当然这个值也可以自己来决定.但是为了一致性,还是使用标准的值较好。PhoneNumberUtils.convertKeypadLettersToDigits 顾名思义.将字母转换为数字,类似于T9输入法,Context.getCacheDir() 获取缓存数据文件夹的路径,很简单但是知道的人不多,这个路径通常在SD卡上(这里的SD卡指的是广义上的SD卡,包括外部存储和内部存储)Adnroid/data/您的应用程序包名/cache/  下面.测试的时候,可以去这里面看是否缓存成功.缓存在这里的好处是:不用自己再去手动创建文件夹,不用担心用户把自己创建的文件夹删掉,在应用程序卸载的时候,这里会被清空,使用第三方的清理工具的时候,这里也会被清空。ArgbEvaluator 用于处理颜色的渐变。就像 Chris Banes 说的一样，这个类会进行很多自动装箱的操作，所以最好还是去掉它的逻辑自己去实现它。这个没用过,不明其所以然,回头再补充.ContextThemeWrapper 方便在运行的时候修改主题。Space space是Android 4.0中新增的一个控件，它实际上可以用来分隔不同的控件，其中形成一个空白的区域.这是一个轻量级的视图组件，它可以跳过Draw，对于需要占位符的任何场景来说都是很棒的。ValueAnimator.reverse() 这个方法可以很顺利地取消正在运行的动画。———————————————————————————————————————————Part 2:DateUtils.formatDateTime() 用来进行区域格式化工作，输出格式化和本地化的时间或者日期。AlarmManager.setInexactRepeating 通过闹铃分组的方式省电，即使你只调用了一个闹钟，这也是一个好的选择，（可以确保在使用完毕时自动调用 AlarmManager.cancel ()。原文说的比较抽象，这里详细说一下:setInexactRepeating指的是设置非准确闹钟，使用方法:alarmManager.setInexactRepeating(AlarmManager.RTC， startTime，intervalL， pendingIntent)，非准确闹钟只能保证大致的时间间隔，但是不一定准确，可能出现设置间隔为30分钟，但是实际上一次间隔20分钟，另一次间隔40分钟。它的最大的好处是可以合并闹钟事件，比如间隔设置每30分钟一次，不唤醒休眠，在休眠8小时后已经积累了16个闹钟事件，而在手机被唤醒的时候，非准时闹钟可以把16个事件合并为一个， 所以这么看来，非准时闹钟一般来说比较节约能源。Formatter.formatFileSize() 一个区域化的文件大小格式化工具。通俗来说就是把大小转换为MB，G，KB之类的字符串。ActionBar.hide()/.show() 顾名思义，隐藏和显示ActionBar，可以优雅地在全屏和带Actionbar之间转换。Linkify.addLinks() 在Text上添加链接。很实用。StaticLayout 在自定义 View 中渲染文字的时候很实用。Activity.onBackPressed() 很方便的管理back键的方法，有时候需要自己控制返回键的事件的时候，可以重写一下。比如加入 “点两下back键退出” 功能。GestureDetector 用来监听和相应对应的手势事件，比如点击，长按，慢滑动，快滑动，用起来很简单，比你自己实现要方便许多。DrawFilter 可以让你在不调用onDrew方法的情况下，操作canvas，比了个如，你可以在创建自定义 View 的时候设置一个 DrawFilter，给父 View 里面的所有 View 设置反别名。ActivityManager.getMemoryClass() 告诉你你的机器还有多少内存，在计算缓存大小的时候会比较有用。ViewStub 它是一个初始化不做任何事情的 View，但是之后可以载入一个布局文件。在慢加载 View 中很适合做占位符。唯一的缺点就是不支持标签，所以如果你不太小心的话，可能会在视图结构中加入不需要的嵌套。SystemClock.sleep() 这个方法在保证一定时间的 sleep 时很方便，通常我用来进行 debug 和模拟网络延时。DisplayMetrics.density 这个方法你可以获取设备像素密度，大部分时候最好让系统来自动进行缩放资源之类的操作，但是有时候控制的效果会更好一些.(尤其是在自定义View的时候)。Pair.create() 方便构建类和构造器的方法。———————————————————————————————————————————Part 3:UrlQuerySanitizer——使用这个工具可以方便对 URL 进行检查。Fragment.setArguments——因为在构建 Fragment 的时候不能加参数，所以这是个很好的东西，可以在创建 Fragment 之前设置参数（即使在 configuration 改变的时候仍然会导致销毁/重建）。DialogFragment.setShowsDialog ()—— 这是一个很巧妙的方式，DialogFragment 可以作为正常的 Fragment 显示！这里可以让 Fragment 承担双重任务。我通常在创建 Fragment 的时候把 onCreateView ()和 onCreateDialog ()都加上，就可以创建一个具有双重目的的 Fragment。FragmentManager.enableDebugLogging ()——在需要观察 Fragment 状态的时候会有帮助。LocalBroadcastManager——这个会比全局的 broadcast 更加安全，简单，快速。像 otto 这样的 Event buses 机制对你的应用场景更加有用。PhoneNumberUtils.formatNumber ()——顾名思义，这是对数字进行格式化操作的时候用的。Region.op()——我发现在对比两个渲染之前的区域的时候很实用，如果你有两条路径，那么怎么知道它们是不是会重叠呢？使用这个方法就可以做到。Application.registerActivityLifecycleCallbacks——虽然缺少官方文档解释，不过我想它就是注册 Activity 的生命周期的一些回调方法（顾名思义），就是一个方便的工具。versionNameSuffix——这个 gradle 设置可以让你在基于不同构建类型的 manifest 中修改版本名这个属性，例如，如果需要在在 debug 版本中以”-SNAPSHOT”结尾，那么就可以轻松的看出当前是 debug 版还是 release 版。CursorJoiner——如果你是只使用一个数据库的话，使用 SQL 中的 join 就可以了，但是如果收到的数据是来自两个独立的 ContentProvider，那么 CursorJoiner 就很实用了。Genymotion——一个非常快的 Android 模拟器，本人一直在用。-nodpi——在没有特别定义的情况下，很多修饰符(-mdpi,-hdpi,-xdpi等等)都会默认自动缩放 assets/dimensions，有时候我们需要保持显示一致，这种情况下就可以使用 -nodpi。BroadcastRecevier.setDebugUnregister ()——又一个方便的调试工具。Activity.recreate ()——强制让 Activity 重建。PackageManager.checkSignatures ()——如果同时安装了两个 app 的话，可以用这个方法检查。如果不进行签名检查的话，其他人可以轻易通过使用一样的包名来模仿你的 app。———————————————————————————————————————————Part 4:Activity.isChangingConfigurations ()——如果在 Activity 中 configuration 会经常改变的话，使用这个方法就可以不用手动做保存状态的工作了。SearchRecentSuggestionsProvider——可以创建最近提示效果的 provider，是一个简单快速的方法。ViewTreeObserver——这是一个很棒的工具。可以进入到 VIew 里面，并监控 View 结构的各种状态，通常我都用来做 View 的测量操作（自定义视图中经常用到）。org.gradle.daemon=true——这句话可以帮助减少 Gradle 构建的时间，仅在命令行编译的时候用到，因为 Android Studio 已经这样使用了。DatabaseUtils——一个包含各种数据库操作的使用工具。android:weightSum (LinearLayout)——如果想使用 layout weights，但是却不想填充整个 LinearLayout 的话，就可以用 weightSum 来定义总的 weight 大小。android:duplicateParentState (View)——此方法可以使得子 View 可以复制父 View 的状态。比如如果一个 ViewGroup 是可点击的，那么可以用这个方法在它被点击的时候让它的子 View 都改变状态。android:clipChildren (ViewGroup)——如果此属性设置为不可用，那么 ViewGroup 的子 View 在绘制的时候会超出它的范围，在做动画的时候需要用到。android:fillViewport (ScrollView)——在这片文章中有详细介绍文章链接，可以解决在 ScrollView 中当内容不足的时候填不满屏幕的问题。android:tileMode (BitmapDrawable)——可以指定图片使用重复填充的模式。android:enterFadeDuration/android:exitFadeDuration (Drawables)——此属性在 Drawable 具有多种状态的时候，可以定义它展示前的淡入淡出效果。android:scaleType (ImageView)——定义在 ImageView 中怎么缩放/剪裁图片，一般用的比较多的是“centerCrop”和“centerInside”。Merge——此标签可以在另一个布局文件中包含别的布局文件，而不用再新建一个 ViewGroup，对于自定义 ViewGroup 的时候也需要用到；可以通过载入一个带有标签的布局文件来自动定义它的子部件。AtomicFile——通过使用备份文件进行文件的原子化操作。这个知识点之前我也写过，不过最好还是有出一个官方的版本比较好。———————————————————————————————————————————Part 5:ViewDragHelper ——视图拖动是一个比较复杂的问题。这个类可以帮助解决不少问题。如果你需要一个例子，DrawerLayout就是利用它实现扫滑。Flavient Laurent 还写了一些关于这方面的优秀文章。PopupWindow——Android到处都在使用PopupWindow ，甚至你都没有意识到（标题导航条ActionBar，自动补全AutoComplete，编辑框错误提醒Edittext Errors）。这个类是创建浮层内容的主要方法。Actionbar.getThemrContext()——导航栏的主题化是很复杂的（不同于Activity其他部分的主题化）。你可以得到一个上下文（Context），用这个上下文创建的自定义组件可以得到正确的主题。ThumbnailUtils——帮助创建缩略图。通常我都是用现有的图片加载库（比如，Picasso 或者 Volley），不过这个ThumbnaiUtils可以创建视频缩略图。译者注：该API从V8才开始支持。Context.getExternalFilesDir()———— 申请了SD卡写权限后，你可以在SD的任何地方写数据，把你的数据写在设计好的合适位置会更加有礼貌。这样数据可以及时被清理，也会有更好的用户体验。此外，Android 4.0 Kitkat中在这个文件夹下写数据是不需要权限的，每个用户有自己的独立的数据存储路径。译者注：该API从V8才开始支持。SparseArray——Map的高效优化版本。推荐了解姐妹类SparseBooleanArray、SparseIntArray和SparseLongArray。PackageManager.setComponentEnabledSetting()——可以用来启动或者禁用程序清单中的组件。对于关闭不需要的功能组件是非常赞的，比如关掉一个当前不用的广播接收器。SQLiteDatabase.yieldIfContendedSafely()——让你暂时停止一个数据库事务， 这样你可以就不会占用太多的系统资源。Environment.getExternalStoragePublicDirectory()——还是那句话，用户期望在SD卡上得到统一的用户体验。用这个方法可以获得在用户设备上放置指定类型文件（音乐、图片等）的正确目录。View.generateViewId()——每次我都想要推荐动态生成控件的ID。需要注意的是，不要和已经存在的控件ID或者其他已经生成的控件ID重复。ActivityManager.clearApplicationUserData()—— 一键清理你的app产生的用户数据，可能是做用户退出登录功能，有史以来最简单的方式了。Context.createConfigurationContext() ——自定义你的配置环境信息。我通常会遇到这样的问题：强制让一部分显示在某个特定的环境下（倒不是我一直这样瞎整，说来话长，你很难理解）。用这个实现起来可以稍微简单一点。ActivityOptions ——方便的定义两个Activity切换的动画。 使用ActivityOptionsCompat 可以很好解决旧版本的兼容问题。AdapterViewFlipper.fyiWillBeAdvancedByHostKThx()——仅仅因为很好玩，没有其他原因。在整个安卓开源项目中（AOSP the Android ——pen Source Project Android开放源代码项目）中还有其他很有意思的东西（比如GRAVITY_DEATH_STAR_I）。不过，都不像这个这样，这个确实有用ViewParent.requestDisallowInterceptTouchEvent() ——Android系统触摸事件机制大多时候能够默认处理，不过有时候你需要使用这个方法来剥夺父级控件的控制权。==============================&gt;&gt; 以上 &lt;&lt;===============================译文出自 @Gracker 的博客，Android Performance：Part1: [译]Android小技巧(1)Part2: [译]Android小技巧(2)Part3：[译]Android小技巧(3)Part4: [译]Android小技巧(4)Part5: [译]Android小技巧(5)原文出自  Dan Lew 的博客，有 5 篇，强烈推荐。Android Tips Round-Up, Part 1Android Tips Round-Up, Part 2Android Tips Round-Up, Part 3Android Tips Round-Up, Part 4Android Tips Round-Up, Part 5最后做个福利广告 zhengxiaopeng/android-dev-bookmarks · GitHub=============================&gt;&gt;  以下个人补充 &lt;&lt;=============================1、android:clipChildren 和 android:clipToPadding：clipToPadding就是说控件的绘制区域是否在padding里面的，true的情况下如果你设置了padding那么绘制的区域就往里 缩，clipChildren是指子控件是否超过padding区域，这两个属性默认是true的，所以在设置了padding情况下，默认滚动是在 padding内部的，要达到上面的效果主要把这两个属性设置了false那么这样子控件就能画到padding的区域了。使用场景如：ActionBar（透明）下显示Listview而第一项要在actionbar下。参见 android:clipToPadding和android:clipChildren。2、Fragment 的 setUserVisibleHint 方法，可实现 fragment 对用户可见时才加载资源（延迟加载）。3、自定义 View 时重写 hasOverlappingRendering 方法指定 View 是否有 Overlapping 的情况，提高渲染性能。4、AutoScrollHelper，在可滚动视图中长按边缘实现滚动，Android View.OnTouchListener 的子类。5、TouchSlop，系统所能识别出的被认为是最小的滑动距。离，ViewConfiguration.get(context).getScaledTouchSlop()。6、VelocityTracker，可用于 View 滑动事件速度跟踪。7、AlphabetIndexer，字母索引辅助类。8、Messenger，AIDL 实现的封装，比手写 AIDL 更方便。9、ArrayMap，比 HashMap 更高的内存效率，但比 HashMap 慢，不适合有大量数据的场景。10、Property，抽象类，封装出对象中的一个易变的属性值，使用场景如在使用属性动画时对动画属性的操作。11、SortedList，v7 包中，见名知意。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/23/Android开发中，有哪些让你觉得相见恨晚的方法、类或接口/" data-id="cjabwqtn3000chhyu85sxd2us" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android开发中常见的5大内存泄漏问题及解决办法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/23/Android开发中常见的5大内存泄漏问题及解决办法/" class="article-date">
  <time datetime="2017-11-23T03:17:19.775Z" itemprop="datePublished">2017-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android开发中常见的5大内存泄漏问题及解决办法"><a href="#Android开发中常见的5大内存泄漏问题及解决办法" class="headerlink" title="Android开发中常见的5大内存泄漏问题及解决办法"></a>Android开发中常见的5大内存泄漏问题及解决办法</h1><p>在android开发中，内存泄漏是比较常见的问题，有过一些android编程经历的童鞋应该都遇到过，但为什么会出现内存泄漏呢？内存泄漏又有什么影响呢？</p>
<p>在android程序开发中，当一个对象已经不需要再使用了，本该被回收时，而另外一个正在使用的对象持有它的引用从而导致它不能被回收，这就导致本该被回收的对象不能被回收而停留在堆内存中，内存泄漏就产生了。</p>
<p>内存泄漏有什么影响呢？它是造成应用程序OOM的主要原因之一。由于android系统为每个应用程序分配的内存有限，当一个应用中产生的内存泄漏比较多时，就难免会导致应用所需要的内存超过这个系统分配的内存限额，这就造成了内存溢出而导致应用Crash。</p>
<p>了解了内存泄漏的原因及影响后，我们需要做的就是掌握常见的内存泄漏，并在以后的android程序开发中，尽量避免它。下面小编搜罗了5个android开发中比较常见的内存泄漏问题及解决办法，分享给大家，一起来看看吧。</p>
<h2 id="一、单例造成的内存泄漏"><a href="#一、单例造成的内存泄漏" class="headerlink" title="一、单例造成的内存泄漏"></a>一、单例造成的内存泄漏</h2><p>Android的单例模式非常受开发者的喜爱，不过使用的不恰当的话也会造成内存泄漏。因为单例的静态特性使得单例的生命周期和应用的生命周期一样长，这就说明了如果一个对象已经不需要使用了，而单例对象还持有该对象的引用，那么这个对象将不能被正常回收，这就导致了内存泄漏。</p>
<p>如下这个典例：</p>
<pre><code>public class AppManager {
    private static AppManager instance;
    private Context context;
    private AppManager(Context context) {
        this.context = context;
    }
    public static AppManager getInstance(Context context) {
        if (instance != null) {
            instance = new AppManager(context);
        }
        return instance;
    }
}
</code></pre><p>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个Context，所以这个Context的生命周期的长短至关重要：</p>
<p>1、传入的是Application的Context：这将没有任何问题，因为单例的生命周期和Application的一样长 ；</p>
<p>2、传入的是Activity的Context：当这个Context所对应的Activity退出时，由于该Context和Activity的生命周期一样长（Activity间接继承于Context），所以当前Activity退出时它的内存并不会被回收，因为单例对象持有该Activity的引用。</p>
<p>所以正确的单例应该修改为下面这种方式：</p>
<pre><code>public class AppManager {
    private static AppManager instance;
    private Context context;
    private AppManager(Context context) {
        this.context = context.getApplicationContext();
    }
    public static AppManager getInstance(Context context) {
        if (instance != null) {
            instance = new AppManager(context);
        }
        return instance;
    }
}
</code></pre><p>这样不管传入什么Context最终将使用Application的Context，而单例的生命周期和应用的一样长，这样就防止了内存泄漏。</p>
<h2 id="二、非静态内部类创建静态实例造成的内存泄漏"><a href="#二、非静态内部类创建静态实例造成的内存泄漏" class="headerlink" title="二、非静态内部类创建静态实例造成的内存泄漏"></a>二、非静态内部类创建静态实例造成的内存泄漏</h2><p>有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，会出现这种写法：</p>
<pre><code>public class MainActivity extends AppCompatActivity {
    private static TestResource mResource = null;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        if(mManager == null){
            mManager = new TestResource();
        }
        //...
    }
    class TestResource {
        //...
    }
}
</code></pre><p>这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而又使用了该非静态内部类创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。</p>
<p>正确的做法为：<br>将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请使用ApplicationContext 。</p>
<h2 id="三、Handler造成的内存泄漏"><a href="#三、Handler造成的内存泄漏" class="headerlink" title="三、Handler造成的内存泄漏"></a>三、Handler造成的内存泄漏</h2><p>Handler的使用造成的内存泄漏问题应该说最为常见了，平时在处理网络任务或者封装一些请求回调等api都应该会借助Handler来处理，对于Handler的使用代码编写一不规范即有可能造成内存泄漏，如下示例：</p>
<pre><code>public class MainActivity extends AppCompatActivity {
    private Handler mHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            //...
        }
    };
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        loadData();
    }
    private void loadData(){
        //...request
        Message message = Message.obtain();
        mHandler.sendMessage(message);
    }
}
</code></pre><p>这种创建Handler的方式会造成内存泄漏，由于mHandler是Handler的非静态匿名内部类的实例，所以它持有外部类Activity的引用，我们知道消息队列是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏，所以另外一种做法为：</p>
<pre><code>public class MainActivity extends AppCompatActivity {
    private MyHandler mHandler = new MyHandler(this);
    private TextView mTextView ;
    private static class MyHandler extends Handler {
        private WeakReference&lt;Context&gt; reference;
        public MyHandler(Context context) {
            reference = new WeakReference&lt;&gt;(context);
        }
        @Override
        public void handleMessage(Message msg) {
            MainActivity activity = (MainActivity) reference.get();
            if(activity != null){
                activity.mTextView.setText(&quot;&quot;);
            }
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mTextView = (TextView)findViewById(R.id.textview);
        loadData();
    }

    private void loadData() {
        //...request
        Message message = Message.obtain();
        mHandler.sendMessage(message);
    }
}
</code></pre><p>创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，不过Looper线程的消息队列中还是可能会有待处理的消息，所以我们在Activity的Destroy时或者Stop时应该移除消息队列中的消息，更准确的做法如下：</p>
<pre><code>public class MainActivity extends AppCompatActivity {
    private MyHandler mHandler = new MyHandler(this);
    private TextView mTextView ;
    private static class MyHandler extends Handler {
        private WeakReference&lt;Context&gt; reference;
        public MyHandler(Context context) {
            reference = new WeakReference&lt;&gt;(context);
        }
        @Override
        public void handleMessage(Message msg) {
            MainActivity activity = (MainActivity) reference.get();
            if(activity != null){
                activity.mTextView.setText(&quot;&quot;);
            }
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mTextView = (TextView)findViewById(R.id.textview);
        loadData();
    }

    private void loadData() {
        //...request
        Message message = Message.obtain();
        mHandler.sendMessage(message);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        mHandler.removeCallbacksAndMessages(null);
    }
}
</code></pre><p>使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages();来移除指定的Runnable和Message。</p>
<h2 id="四、线程造成的内存泄漏"><a href="#四、线程造成的内存泄漏" class="headerlink" title="四、线程造成的内存泄漏"></a>四、线程造成的内存泄漏</h2><p>对于线程造成的内存泄漏，也是平时比较常见的，如下这两个示例可能每个人都这样写过：</p>
<p>//——————test1</p>
<pre><code>new AsyncTask&lt;Void, Void, Void&gt;() {
    @Override
    protected Void doInBackground(Void... params) {
        SystemClock.sleep(10000);
        return null;
    }
}.execute();
</code></pre><p>//——————test2</p>
<pre><code>new Thread(new Runnable() {
    @Override
    public void run() {
        SystemClock.sleep(10000);
    }
}).start();
</code></pre><p>上面的异步任务和Runnable都是一个匿名内部类，因此它们对当前Activity都有一个隐式引用。如果Activity在销毁之前，任务还未完成， 那么将导致Activity的内存资源无法回收，造成内存泄漏。正确的做法还是使用静态内部类的方式，如下：</p>
<pre><code>static class MyAsyncTask extends AsyncTask&lt;Void, Void, Void&gt; {
    private WeakReference&lt;Context&gt; weakReference;

    public MyAsyncTask(Context context) {
        weakReference = new WeakReference&lt;&gt;(context);
    }

    @Override
    protected Void doInBackground(Void... params) {
        SystemClock.sleep(10000);
        return null;
    }

    @Override
    protected void onPostExecute(Void aVoid) {
        super.onPostExecute(aVoid);
        MainActivity activity = (MainActivity) weakReference.get();
        if (activity != null) {
            //...
        }
    }
}
static class MyRunnable implements Runnable{
    @Override
    public void run() {
        SystemClock.sleep(10000);
    }
}
</code></pre><p>//——————</p>
<pre><code>new Thread(new MyRunnable()).start();
new MyAsyncTask(this).execute();
</code></pre><p>这样就避免了Activity的内存资源泄漏，当然在Activity销毁时候也应该取消相应的任务AsyncTask::cancel()，避免任务在后台执行浪费资源。</p>
<h2 id="五、资源未关闭造成的内存泄漏"><a href="#五、资源未关闭造成的内存泄漏" class="headerlink" title="五、资源未关闭造成的内存泄漏"></a>五、资源未关闭造成的内存泄漏</h2><p>对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p>
<p>以上就是android编程中，常见的5大内存泄漏问题及相应的解决办法，如果大家在编程中遇到了上述泄漏问题，不妨可以试试对应的方法。如果大家还有什么疑问，可以去“学习问答”版块直接提出。</p>
<h2 id="参考信息"><a href="#参考信息" class="headerlink" title="参考信息"></a>参考信息</h2><p><a href="http://www.maiziedu.com/article/9126/" target="_blank" rel="noopener">Android开发中常见的5大内存泄漏问题及解决办法</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/23/Android开发中常见的5大内存泄漏问题及解决办法/" data-id="cjabwqtmy000bhhyuordzct8z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android 启动白屏" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/23/Android 启动白屏/" class="article-date">
  <time datetime="2017-11-23T03:17:19.763Z" itemprop="datePublished">2017-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android-启动白屏"><a href="#Android-启动白屏" class="headerlink" title="Android 启动白屏"></a>Android 启动白屏</h1><h2 id="启动页面-Android-Starting-Window-Preview-Window"><a href="#启动页面-Android-Starting-Window-Preview-Window" class="headerlink" title="启动页面 Android Starting Window(Preview Window)"></a>启动页面 Android Starting Window(Preview Window)</h2><p>当打开一个Activity时，如果这个Activity所属的应用还没有在运行，系统会为这个Activity所属的应用创建一个进程，但进程的创建与初始化都需要时间，在这个动作完成之前系统要做什么呢？如果没有任何反应的话，如果程序初始化的时间很长，用户可能还以为没有点到相应的位置。但此时所启动的程序还没初始化完，既无法显示程序，又不能停在原处不做任何动作，怎么办？这就有了<strong>Starting Window</strong>的概念，也可以称之为<strong>Preview Window</strong>。</p>
<p>Starting Window就是一个用于在应用程序进程创建并初始化成功前显示的临时窗口，拥有的Window Type是TYPE_APPLICATION_STARTING。在程序初始化完成前显示这个窗口，以告知用户系统已经知道了他要打开这个应用并做出了响应，当程序初始化完成后显示用户UI并移除这个窗口。</p>
<p>这个Starting Window我们都见过，不过可能没留意过，其实就是开启程序时黑屏的那个窗口，够丑的。不过也没办法，每个程序的界面都不是同的，系统只有默认显示一个很简单的窗口了。</p>
<p>如果所谓的Starting Window只是一个黑屏的窗口的话，那这个功能未免也太鸡肋了。其实系统是可以根据每个程序的Theme显示不同的样子的。</p>
<p>启动应用的时候，虽然我们的程序还没初始化，但程序内的组件可是在程序安装的时候就被系统分析注册了的。我们可以针对每个Application和Activity设置不同的Theme，系统就是根据这个Theme初始化Starting Window的。Window布局的顶层是DecorView，Starting Window就是显示一个空的但是应用了Activity指定的Theme（如果Activity没有指定就用Application的）的DecorView。</p>
<p>在Theme中可以指定很多东西，如ActionBar的样式，窗口的背景，Activity的图标等，通过给Activity指定Theme，系统就可以在我们的应用初始化完成之前将这个Theme应用到Starting Window，这样看起来就像我们的应用已经启动起来了，只是数据内容还没有初始化好。</p>
<p>所以，如果你的Activity的背景只是简单的纯色的话，最好直接通过Theme把它应用到Activity的Background，而不是设置为顶层Layout的背景，如果真的需要给顶层Layout设置背景，也可以给android:windowBackground设置一个和Activity UI相似的背景，为了防止Overdraw，在Activity的onCreate中通过setWindowBackground()再把窗口的背景设置为null。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>设置主题 （设置透明背景 或 添加与 Splash 启动页相同的图片）</p>
<pre><code>&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt;
    ......
    &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;
&lt;/style&gt;


&lt;style name=&quot;AppSplash&quot; parent=&quot;android:Theme&quot;&gt;    
    &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/ipod_bg&lt;/item&gt;    
    &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;    
&lt;/style&gt;  
</code></pre><p>应用主题</p>
<pre><code>&lt;activity   
   android:theme=&quot;@style/AppSplash&quot;  
   android:name=&quot;.SplashActivity&quot; &gt;  
&lt;/activity&gt;  
</code></pre><p>tip:</p>
<p>如果在 splash 的 theme 设置背景的话，那么就可以去掉 layout 中的相同图片，防止可能出现的图片跳动现象</p>
<h2 id="参考信息"><a href="#参考信息" class="headerlink" title="参考信息"></a>参考信息</h2><p><a href="http://www.cnblogs.com/angeldevil/p/3801209.html" target="_blank" rel="noopener">Android Starting Window(Preview Window)</a></p>
<p><a href="http://www.2cto.com/kf/201604/503761.html" target="_blank" rel="noopener">Android 应用启动界面分析（Starting Window）</a></p>
<p><a href="http://blog.csdn.net/zivensonice/article/details/51691136" target="_blank" rel="noopener">Android App 启动页(Splash)黑/白闪屏现象产生原因与解决办法</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/23/Android 启动白屏/" data-id="cjabwqtm10007hhyuwlz09f3d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-android 各种遇到的问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/23/android 各种遇到的问题/" class="article-date">
  <time datetime="2017-11-23T03:17:19.755Z" itemprop="datePublished">2017-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="android-各种遇到的问题"><a href="#android-各种遇到的问题" class="headerlink" title="android 各种遇到的问题"></a>android 各种遇到的问题</h1><h2 id="android-support-v4-view-ViewPager-cannot-be-cast-to-android-widget-TextView"><a href="#android-support-v4-view-ViewPager-cannot-be-cast-to-android-widget-TextView" class="headerlink" title="android.support.v4.view.ViewPager cannot be cast to android.widget.TextView"></a>android.support.v4.view.ViewPager cannot be cast to android.widget.TextView</h2><p>fragment</p>
<pre><code>@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    // 1 出错
    View view = inflater.inflate(R.layout.fragment_page, container);//布局转换为视图控件
    TextView textView = (TextView) view;//向下转型
    //2 出错
    TextView textView = (TextView) inflater.inflate(R.layout.fragment_page, container)；

    textView.setText(&quot;Fragment #&quot; + mPage);
    return view;
}
</code></pre><p>fragment_page 布局文件</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:gravity=&quot;center&quot;/&gt;
</code></pre><p>解决方法：</p>
<p>布局文件添加 id</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:id=&quot;@+id/my_text&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:gravity=&quot;center&quot;/&gt;
</code></pre><p>fragment onCreateView 更改为</p>
<pre><code>View view = inflater.inflate(R.layout.fragment_page, container);
TextView textView = (TextView) view.findViewById(R.id.my_text);
textView.setText(&quot;Fragment #&quot; + mPage);
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/23/android 各种遇到的问题/" data-id="cjabwqtnt000vhhyu0wbb89zl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-android 加解密" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/23/android 加解密/" class="article-date">
  <time datetime="2017-11-23T03:17:19.747Z" itemprop="datePublished">2017-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="android-加解密"><a href="#android-加解密" class="headerlink" title="android 加解密"></a>android 加解密</h1><p>使用对称加密算法来保存，比如3DES、AES等算法</p>
<p>使用MD5、SHA1等单向HASH算法保护密码</p>
<p>特殊的单向HASH算法</p>
<p>PBKDF2算法</p>
<p>bcrypt、scrypt等算法</p>
<h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><p><strong>拖库</strong>本来是数据库领域的术语，指从数据库中导出数据。到了黑客攻击泛滥的今天，它被用来指网站遭到入侵后，黑客窃取其数据库。</p>
<p><strong>加盐</strong></p>
<h2 id="参考信息"><a href="#参考信息" class="headerlink" title="参考信息"></a>参考信息</h2><p><a href="http://blog.csdn.net/ronghua_liu/article/details/8577487" target="_blank" rel="noopener">（总结）密码破解之王：Ophcrack彩虹表(Rainbow Tables)原理详解（附：120G彩虹表下载）</a></p>
<p><a href="http://blog.csdn.net/w18756901575/article/details/51373693" target="_blank" rel="noopener">Android 对用户名密码进行加密操作存储在本地</a></p>
<p><a href="http://www.92to.com/xinwen/2016/11-08/12726882.html" target="_blank" rel="noopener">android常见加密方式 常见的用户密码加密方式以及破解方法</a></p>
<p><a href="https://juejin.im/entry/5791c4b78ac247005f0c4333" target="_blank" rel="noopener">android 中保存静态秘钥实践</a></p>
<p><a href="https://www.zhihu.com/question/20299384" target="_blank" rel="noopener">加盐密码保存的最通用方法是？</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/23/android 加解密/" data-id="cjabwqtns000uhhyuq8g5l6rd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android中实现滑动的七种方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/23/Android中实现滑动的七种方式/" class="article-date">
  <time datetime="2017-11-23T03:17:19.739Z" itemprop="datePublished">2017-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android中实现滑动的七种方式"><a href="#Android中实现滑动的七种方式" class="headerlink" title="Android中实现滑动的七种方式"></a>Android中实现滑动的七种方式</h1><h2 id="android-坐标体系"><a href="#android-坐标体系" class="headerlink" title="android 坐标体系"></a>android 坐标体系</h2><h3 id="android-坐标系"><a href="#android-坐标系" class="headerlink" title="android 坐标系"></a>android 坐标系</h3><p>Android坐标系的坐标原点位于屏幕的左上角</p>
<h3 id="视图坐标系"><a href="#视图坐标系" class="headerlink" title="视图坐标系"></a>视图坐标系</h3><p>视图坐标系的原点位于父视图的左上角</p>
<h2 id="实现滑动方式"><a href="#实现滑动方式" class="headerlink" title="实现滑动方式"></a>实现滑动方式</h2><h3 id="layout-方法"><a href="#layout-方法" class="headerlink" title="layout 方法"></a>layout 方法</h3><p>在View进行绘制时，是调用onLayout()方法来确定View的位置的，同样我们也可以调用layout()方法来传入我们滑动后的坐标便可以实现View的滑动，当然坐标的获取我们可以在触控事件中进行获取，下面我们做一个View随手指进行滑动的小例子来进行说明。</p>
<pre><code>public class DragView extends View {
    private int mLastX;
    private int mLastY;
    public DragView(Context context) {
        this(context, null);
    }

    public DragView(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public DragView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        int x = (int) event.getX();
        int y = (int) event.getY();
        int lastX = 0, lastY = 0;
        switch (event.getAction()){
            case MotionEvent.ACTION_DOWN:
                mLastX = x;
                mLastY = y;
                break;
            case MotionEvent.ACTION_MOVE:
                int offsetX = x - mLastX;
                int offsetY = y - mLastY;
                layout(getLeft() + offsetX, getTop() + offsetY,
                        getRight() + offsetX, getBottom() + offsetY);
                break;
        }
        return true;
    }
}
</code></pre><p>上面我们在触控事件中获取到获取到手指按下时的坐标(lastX, lastY)，然后在手指移动时不断计算X和Y方向上的偏移量，然后再调用layout()方法来改变View的位置从而实现滑动。当然上面我们是通过getX()和getY()来获取视图坐标来进行修改，我们也可以通过getRawX()和getRawY()来获取绝对坐标来实现上面的效果。代码如下:</p>
<pre><code>private int mLastX;
private int mLastY;
@Override
public boolean onTouchEvent(MotionEvent event) {
    int x = (int) event.getRawX();
    int y = (int) event.getRawY();
    switch (event.getAction()){
        case MotionEvent.ACTION_DOWN:
            mLastX = x;
            mLastY = y;
            break;
        case MotionEvent.ACTION_MOVE:
            int offsetX = x - mLastX;
            int offsetY = y - mLastY;
            layout(getLeft() + offsetX, getTop() + offsetY,
                    getRight() + offsetX, getBottom() + offsetY);
            //重新设置初始坐标
            mLastX = x;
            mLastY = y;
            break;
    }
    return true;
}
</code></pre><p>上面一定要注意，我们在改变完View的位置后必须调用设置初始坐标，这样才能准确获取偏移量。</p>
<h3 id="offsetLeftAndRight和offsetTopAndBottom"><a href="#offsetLeftAndRight和offsetTopAndBottom" class="headerlink" title="offsetLeftAndRight和offsetTopAndBottom"></a>offsetLeftAndRight和offsetTopAndBottom</h3><p>这一种方法和上一种方法大部分步骤都是相同的，只是在移动View上有所差别，代码如下（只替换 layout ）:</p>
<p>offsetLeftAndRight(offsetX);</p>
<p>offsetTopAndBottom(offsetY);</p>
<pre><code>public class DragView extends View {
    private int mLastX;
    private int mLastY;
    public DragView(Context context) {
        this(context, null);
    }

    public DragView(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public DragView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        int x = (int) event.getX();
        int y = (int) event.getY();
        int lastX = 0, lastY = 0;
        switch (event.getAction()){
            case MotionEvent.ACTION_DOWN:
                mLastX = x;
                mLastY = y;
                break;
            case MotionEvent.ACTION_MOVE:
                int offsetX = x - mLastX;
                int offsetY = y - mLastY;
                offsetLeftAndRight(offsetX);
                offsetTopAndBottom(offsetY);
                break;
        }
        return true;
    }
}
</code></pre><h3 id="设置LayoutParams"><a href="#设置LayoutParams" class="headerlink" title="设置LayoutParams"></a>设置LayoutParams</h3><p>LayoutParams可以通过改变的布局参数，我们可以通过下面的代码实现上面同样的效果。</p>
<pre><code>LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) getLayoutParams();
layoutParams.leftMargin = getLeft() + offsetX;
layoutParams.topMargin = getTop() + offsetY;
setLayoutParams(layoutParams);
</code></pre><p>注意:我们的LayoutParams可以通过getLayoutParams()方法来获取，但是要注意，如果View的父布局是LinearLayout，那么我们的LayoutParams就是LinearLayout.LayoutParams，如果View的父布局是RelativeLayout,则我们的LayoutParams就是RelativeLayout.LayoutParams。当然我们还有一种简单的方法，不用再管父布局的布局方式。代码如下:</p>
<pre><code>ViewGroup.MarginLayoutParams marginLayoutParams = (ViewGroup.MarginLayoutParams) getLayoutParams();
marginLayoutParams.leftMargin = getLeft() + offsetX;
marginLayoutParams.topMargin = getTop() + offsetY;
setLayoutParams(marginLayoutParams);
</code></pre><h3 id="scrollTo和scrollBy方法"><a href="#scrollTo和scrollBy方法" class="headerlink" title="scrollTo和scrollBy方法"></a>scrollTo和scrollBy方法</h3><p><strong>关于这两个方法我们需要仔细说一下其中的一些注意事项</strong></p>
<p>1 . scrollTo的参数是具体的一个坐标点(x, y), 而scrollBy的参数是在x, y方向上的坐标偏移</p>
<p>2 . scrollTo和scrollBy移动的是View的内容。这一点很重要!!!!</p>
<p>如果我们对ViewGroup使用scrollTo和scrollBy则移动的是内部的所有子View， 如果对TextView使用scrollTo和scrollBy则移动的是其中额文本。</p>
<p>3 . 视图移动还有一个不太好理解的地方在于坐标，我们下面结合图片来说明一下：</p>
<p>我们可以这样理解，我们的手机屏幕作为一个盖板，在手机屏幕下面是一个巨大的画布，我们的手机屏幕这个盖板是透明的，导致只有和手机屏幕重合的画布部分才会被我们看到，我们调用scrollTo和scrollBy也可以理解为是在移动手机上面的盖板。如图中所示，按钮在ViewGroup中的坐标是(20, 10),当我们调用scrollBy(20, 10)之后，就相当于移动了屏幕上的盖板，然后我们看到的按钮就到了ViewGroup的左上角。这样如果我们想让按钮在水平和竖直方向上各移动20和10个单位，我们就必须调用scrollBy(-20, -10)</p>
<p>经过了上面的知识准备，我们这里也使用scrollBy来实现前面实现的那个View随手指移动的小例子:</p>
<pre><code>((View)getParent()).scrollBy(-offsetX, -offsetY);
</code></pre><h3 id="使用Scroller"><a href="#使用Scroller" class="headerlink" title="使用Scroller"></a>使用Scroller</h3><blockquote>
<p>Scroller也是滑动中很重要的一个角色,进过前面的scrollTo和scrollBy大家也会发现，它们的移动时瞬间完成的，滑动显得十分突兀，Google为了改善用户体验，便给出了Scroller，它可以实现平滑的移动，从而使滑动过程更加真实，用户体验更好，下面我们先简单说说Scroller的实现原理。</p>
</blockquote>
<p>Scroller的实现方式类似于scrollTo和scrollBy，scrollTo和scrollBy的移动都是从一个坐标点瞬间移动到另一个左边点，而Scroller则是将移动的这段距离切分成好几段的微小的位移，然后每一段调用scrollTo来不断移动这些微小的位移，由于人眼的视觉暂留效果，就会给人平滑移动的视觉效果。</p>
<blockquote>
<p>下面我们在上一步的基础上增加一个小功能，第一部分还是View随手指移动，但是当我们松开手指时，让View自己平滑移动到最初始的位置(屏幕左上角),下面我们就来一步步介绍Scroller的用法</p>
</blockquote>
<p>1 . 声明Scroller变量,并在构造方法中进行初始化</p>
<p>2 . 在触控事件的ACTION_UP(手指抬起)事件中传入开始滑动的坐标和需要滑动的距离并触发Scroller的滑动事件</p>
<p>3 . 重写computeScroll(),实现真正的滑动</p>
<p>下面是完整的代码示例:</p>
<pre><code>public class DragView extends View {
    private int mLastX;
    private int mLastY;
    //声明Scroller变量
    private Scroller mScroller;
    public DragView(Context context) {
        this(context, null);
    }

    public DragView(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public DragView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        //在构造方法中初始化Scroller变量
        mScroller = new Scroller(context);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        int x = (int) event.getRawX();
        int y = (int) event.getRawY();
        switch (event.getAction()){
            case MotionEvent.ACTION_DOWN:
                mLastX = x;
                mLastY = y;
                break;
            case MotionEvent.ACTION_MOVE:
                int offsetX = x - mLastX;
                int offsetY = y - mLastY;
                //实现View跟随手指移动的效果
                ((View)getParent()).scrollBy(-offsetX, -offsetY);
                //重新设置初始坐标
                mLastX = x;
                mLastY = y;
                break;
            case MotionEvent.ACTION_UP:
                //当手指抬起时执行滑动过程
                View view = (View) getParent();
                mScroller.startScroll(view.getScrollX(), view.getScrollY(),
                        view.getScrollX(), view.getScrollY(), 5000);
                //调用重绘来间接调用computeScroll()方法
                invalidate();
                break;
        }
        return true;
    }

    @Override
    public void computeScroll() {
        super.computeScroll();
        //判断滑动过程是否完成
        if (mScroller.computeScrollOffset()){
            ((View)getParent()).scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
            //通过重绘来不断调用computeScroll()方法
            invalidate();
        }
    }
}
</code></pre><blockquote>
<p>上面的代码View随手指移动的代码部分是与前面相同的，我们只说说Scroller的部分以及一些注意事项</p>
</blockquote>
<p>1 .  startScroll()方法各参数的意义,我们可以看看下面的源码:</p>
<pre><code>/**
 * Start scrolling by providing a starting point, the distance to travel,
 * and the duration of the scroll.
 *
 * @param startX Starting horizontal scroll offset in pixels. Positive
 *        numbers will scroll the content to the left.
 * @param startY Starting vertical scroll offset in pixels. Positive numbers
 *        will scroll the content up.
 * @param dx Horizontal distance to travel. Positive numbers will scroll the
 *        content to the left.
 * @param dy Vertical distance to travel. Positive numbers will scroll the
 *        content up.
 * @param duration Duration of the scroll in milliseconds.
 */
public void startScroll(int startX, int startY, int dx, int dy, int duration)
</code></pre><p>可以看出startX和startY参数就是开始滚动的(x, y)坐标，那么我们就可以通过ViewGroup(子View的父视图)的getScrollX()和getScrollY()来获取,这里一定要注意，我们在滑动时的content就是子View，所以我们通过子View的父视图(ViewGroup)的getScrollX()和getScrollY()获取到的就是子View在X和Y方向上滑动的距离，即就是我们需要的当我们手指抬起时子View的(x, y)坐标。而如果我们对子View调用getScrollX()和getScrollY()方法，则获得的是子View内部的视图的滑动距离及坐标。</p>
<p>dx和dy分别是在X和Y方向上的偏移量，而且注释中说了，如果我们传入的dx和dy的值是正值，那么将会向上向左移动这个content(其实就是我们这里的View)，即我们就可以让子View回到左上角，这里我们还是可以借助于上一小节中提到的视图移动的概念，我们想让子View向坐上方移动，其实就是想让覆盖在上面的盖板向右下角移动，我们可以将dx和dy理解为父视图(覆盖在上面的盖板)的偏移量。</p>
<p>假设我们刚开始是让子View随手指向右下方移动，那么相当于覆盖在上面的盖板是向左上方移动，所以我们通过getScrollX()和getScrollY()获得的值是负值，我们现在松开手指想让子View向左上方移动(即回到屏幕左上角)，那么就相当于盖板向右下角移动，所以我们的dx和dy的值必须是-getScrollX()和-getScrollY()，此时的两个值都是正值。</p>
<p>2 . 由于我们的computeScroll()方法不会主动调用，但是我们又需要它不断调用从而不断进行微小移动从而实现平滑的滑动，所以我们可以通过下面的方法。</p>
<blockquote>
<p>这三个按照以下顺序进行调用 invalidate()—&gt;onDraw()—&gt;computeScroll()，所以我们可以可以在ACTION_UP中调用完startScroll()方法后调用invalidate()方法,然后在computeScroll()方法中判断滑动是否结束,如果没结束，则通过getCurrX()和getCurrY()来获得当前需要移动的微小的位移的坐标点，然后传入scrollTo()方法中，这时候子View还只是移动了一小段距离，然后我们再次调用invalidate()方法，然后接着调用onDraw()方法，然后再次进入computeScroll()中再次让子View移动一小段距离，直到滑动结束,computeScrollOffset()返回false，则这个循环调用的过程结束，从而完成平滑移动的过程。</p>
</blockquote>
<h3 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h3><p>属性动画一样可以实现View的滑动，但是由于属性动画涉及到的知识点也是众多，这里不再展开来写，只是提供一个思路，后续后专门写一篇博客来说。</p>
<h3 id="ViewDragHelper"><a href="#ViewDragHelper" class="headerlink" title="ViewDragHelper"></a>ViewDragHelper</h3><p>ViewDragHelper可以帮助我们实现各种滑动需求，但是它的使用也相对较复杂，所以准备专门写一篇博客来介绍他，这里只是给出一个概念</p>
<h2 id="参考信息"><a href="#参考信息" class="headerlink" title="参考信息"></a>参考信息</h2><p><a href="http://www.jianshu.com/p/4eaeee19c5e4" target="_blank" rel="noopener">Android中实现滑动的七种方式</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/23/Android中实现滑动的七种方式/" data-id="cjabwqtme000ahhyudqar74tb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu-hexo/">ubuntu hexo</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ubuntu-hexo/" style="font-size: 10px;">ubuntu hexo</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/11/23/设计模式 依赖倒置原则/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/11/23/网络 DNS 网关 路由/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/11/23/程序设计中，为什么要解耦/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/11/23/用于app指向性功能高亮的库/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/11/23/环信 服务器 curl 获取数据/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>