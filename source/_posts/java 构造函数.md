# java 构造函数 #

## 为什么创建了一个子类对象会调用其父类的构造方法 ##

代码实例：

	package simplejava;
	
	class Super {
	    String s;
	    public Super() {
	        System.out.println("Super");
	    }
	}
	
	class Sub extends Super {
	    public Sub() {
	        System.out.println("Sub");
	    }
	
	}
	
	public class Q4 {
	    public static void main(String[] args) {
	        Sub s = new Sub();
	    }
	}

结果打印：

	Super
	Sub

当一个类继承了某个类时，在子类的构造方法里，super()必须先被调用；如果你没有写，编译器会自动调用super()方法，即调用了父类的构造方法；

这并不是创建了两个对象，其实只有一个子类Sub对象；之所以需要调用父类的构造方法是因为在父类中，可能存在私有属性需要在其构造方法内初始化；

当编译器自动插入父类构造方法的调用后，子类的构造方法类似如下代码：

	 public Sub() {
        super();
        System.out.println("Sub");
    }

## 一个常见的错误信息：Implicit super constructor is undefined for default constructor ##

	class Super{
	    String s;
	
	    public Super(String s) {
	        this.s = s;
	    }
	}
	public class Sub extends Super{
    
	    int x = 200;
	
	    public Sub() { //报错
	        System.out.println("Sub");
	    }

	    public Sub(String s) { //报错
	        
	    }
	
	    public static void main(String[] args) {
	        Sub s = new Sub();
	    }
	}

之所以出现这个编译错误，是因为父类的默认构造方法未定义。在Java中，如果一个类没有定义构造方法，编译器会默认插入一个无参数的构造方法；但是如果一个构造方法在父类中已定义，在这种情况，编译器是不会自动插入一个默认的无参构造方法，这正是以上demo的情况；

对于子类来说，不管是无参构造方法还是有参构造方法，都会默认调用父类的无参构造方法；当编译器尝试在子类中往这两个构造方法插入super()方法时，因为父类没有一个默认的无参构造方法，所以编译器报错；

要修复这个错误，很简单：

1、在父类手动定义一个无参构造方法：

	public Super(){
	    System.out.println("Super");
	}
2、移除父类中自定义的构造方法

3、在子类中自己写上父类构造方法的调用；如super(value)；

## 在子类中明确调用父类构造方法

以下代码运行正常：

	class Super{
		    String s;
		
		    public Super(String s) {
		        this.s = s;
		    }
		}
		public class Sub extends Super{
	    
		    int x = 200;
		
		    public Sub(String s) { 
		        super(s)
		    }
		
		    public static void main(String[] args) {
		        Sub s = new Sub();
		    }
		}
	}

父类定义了一个有参构造方法，然后子类构造方法明确调用了父类有参构造方法；

## 规则总结 ##

简单的说，规则是这样的：

在子类构造方法中，不管是程序员手动调用父类构造方法还是编译器自动调用，

子类构造方法必须要调用父类的某个构造方法；

被子类调用的父类构造方法在父类中必须是存在的；

## 一个有趣的问题 ##

如果一个类定义了一个有参数的构造方法，Java为什么就不提供默认的无参构造方法呢？

有兴趣的可以看下stackoverflow中的回答：

http://stackoverflow.com/q/16046200/127859

译文链接：http://www.programcreek.com/2013/04/what-are-the-frequently-asked-questions-about-constructors-in-java/

## 为什么一定要调用父类的构造方法 ##

1. 你想吧，如果你定义了一个有参的构造函数 这时候就不会调用父类构造方法了，因为你有自己的特性了啊。如果你实例化的时候调用的是无参的构造方法当然会走父类的了，因为你没申明自己的特性

2. 楼主 在创建对象的时候如果父类中的数据需要初始化，那么就必须调用，如果父类中的数据不用初始化，也就不用显示的调用了 这个就相当于 你在子类中可以使用父类的变量 但是你在子类中初始化 你不感觉多此一举吗

3. 有父类就会有父类构造方法，这个是必然的。不然可能会出现空指针。
没父类继承时的就只要当前类的构造方法了。

4. 这个是和继承有关系。子类继承父类后。在内部的存储中。子类是没有父类已经定义的那部分。所以在进行new的时候子类只是new了自己的那部分。

5. 任何时候都会调用父类构造函数的吧？
分两种情况：
1.不显示调用父类构造函数，则默认调用父类的无参构造函数。如果父类声明了有参数的构造函数，而没写无参的构造函数，那么编译出错，提示父类没有默认构造函数
2.显示调用父类构造函数，这个简单，你知道父类的哪个构造函数就用这个构造函数初始化父类。

6. 儿子有了东西吃，要先给老子吃，这位老子有了东西，得先给这位老子的老子吃…… 直到最初的上帝Object，他得到他儿子的东西，就自己吃了吧…… 你要理解成“Java教育我们要讲孝心”也可以；但要理解成交税也行；甚至理解成小弟向大哥交保护费也可以…… 呵呵~说笑了! **真实的原因是：实例化的本质，是调用构造函数分配实例标识，申请内存存放实例中各成员变量的初始值。如果该类继承了某个父类，也就继承(相当于复制)了父类的所有非私有成员变量，而如果没有给继承过来的成员变量赋初值，那后续施加在该成员变量的操作如何进行？**

7. 为什么要先调用父类的构造方法？
因为父类的定义的public和protected函数和变量都会自动被继承到子类中，如果父类不初始化，这些定义在父类的函数和变量怎么能在子类中使用？
其实，不仅先调用父类的构造方法，在调用父类的构造方法之前，还先初始化了父类的静态变量和静态块
**完整的初始化顺序是：父类静态变量 父类静态块 子类静态变量 子类静态块 父类非静态变量 父类非静态块 父类构造函数 子类非静态变量 子类非静态块 子类构造函数**

8. 首先实例化就是给对象分配内存，构造方法就是分配内存的实现，那么，子类如何才能更方便的分配内存呢？很显然，就是调用父类构造方法来分配父类部分的内存，然后再调用自己的构造方法来分配子类扩展的内存。否则，如果子类完全从头开始自己分配内存，那么继承父类又有什么优点呢？因为子类的父类部分是完全和父类一样的，你觉得有必要再自己从头开始分配内存吗？既然父类的内存分配已经有现成的方法，为什么不直接调用来分配父类部分的内存呢？

9. 子类实例隐含的包含一个父类实例，拥有一个指向父类实例的引用，当子类实例调用父类中的方法or变量，这个父类必须有一个实例，so在子类实例生成的时候，父类的实例也就生成了啊。


## 参考信息 ##

[关于JAVA中子类和父类的构造方法](https://www.cnblogs.com/chenpi/p/5486096.html#_label0)

[java实例化的时候为什么一定要调用父类的构造方法 ](http://bbs.csdn.net/topics/380077372)